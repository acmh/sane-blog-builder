---
author: lbrito1
comments: true
created_at: 2015-09-11 21:30:30+00:00
kind: article
link: https://codedeposit.wordpress.com/2015/09/11/ruby-dsl-metaprogramming-part-i/
slug: ruby-dsl-metaprogramming-part-i
title: Ruby DSL & metaprogramming, part I
wordpress_id: 148
categories:
- Code
tags:
- DSL
- metaprogramming
- Ruby
---

I've been working with Ruby for nearly a year now, which means I'm starting to feel the urge to tell people how awesome the language is. One of the most interesting aspects of Ruby to me is [metaprogramming](https://en.wikipedia.org/wiki/Metaprogramming), which it seems to have quite a vocation for.

Since college I have a fondness for automata and formal languages theory. One of the topics I particularly like is text generation (if you haven't already, check out the excellent [SCIgen](http://pdos.csail.mit.edu/scigen/) and the [Dada engine](http://dev.null.org/dadaengine/)), so I thought that building a Context-free grammar (CFG)-like text generator in Ruby would be a nice little exercise and an opportunity to use some of the language's coolest features. Also I've implemented one of those using Java several years ago, and it was _a mess_, so I was curious as to how much of an improvement would Ruby offer.

Suppose the following script:

<div class="highlight"><pre><code class="language-ruby">
dictionary 'noun', 'dog', 'bus'
dictionary 'verb', 'barked', 'parked'
dictionary 'preposition', 'at'

rule 'phrase', 'noun', 'verb', 'preposition', 'noun'

codex 'phrase'
</code></pre></div>

We'd like `dictionary` to store some words according to their classes, and `rule` to define a specific ordering of words. For now let's not worry about `codex` (it's just a collection of rules).

At this point the seasoned programmer is mentally sketching some kind of text parser. It's an okay solution, but isn't there something _nicer_ we can do? Well, there is: [DSL](https://en.wikipedia.org/wiki/Domain-specific_language)s! In fact, Ruby is quite an excellent tool to build a DSL, and many famed Ruby-powered applications such as Rspec (and [many others](http://www.leighhalliday.com/creating-ruby-dsl)) define some kind of DSL.

<!-- more -->

Conveniently enough, our little script is actually valid Ruby code (Ruby doesn't care for parenthesis or semicolons). So lets define the dictionary, rule and codex methods:

<div class="highlight"><pre><code class="language-ruby">
#!/usr/bin/env ruby
require_relative 'grammar'
require_relative 'dictionary'
require_relative 'rule'
require_relative 'codex'

@grammar = Grammar.new

def dictionary key, *values
  puts "Read dictionary with: #{key} #{values.to_s}"
  Dictionary.instance.add key, values
end

def rule name, *keys
  puts "Read rule with: #{name} #{keys.to_s}"
  @grammar.rules[name] = Rule.new keys
end

def codex *rulenames
  puts "Read codex with: #{rulenames.to_s}"
  @grammar.codex << (Codex.new rulenames)
end

load 'script.le'
@grammar.generate
</code></pre></div>

Notice the asterisks in the method definitions; they're called splat operators (good reference [here](http://jacopretorius.net/2012/01/splat-operator-in-ruby.html) and [here](https://endofline.wordpress.com/2011/01/21/the-strange-ruby-splat/)). Splats are useful for several things; in our case, we'd like each dictionary entry to have one _key_ (e.g. 'noun') and several _values_: splat takes an arbitrary number of arguments and slurps them into one variable.

So the basic structure is: a `Grammar` has one `Dictionary` and several `Rules` and `Codices`. Text is generated by going running each codex, which applies each of its rules, which combines words together. Simple enough. Here's what output looks like:

<div class="highlight"><pre><code class="language-bash">
lbrito@lbrito:~/Documents/ruby_textgen$ ruby lero.rb
Read dictionary with: noun ["dog", "bus"]
Read dictionary with: verb ["barked", "parked"]
Read dictionary with: preposition ["at"]
Read rule with: phrase ["noun", "verb", "preposition", "noun"]
Read codex with: ["phrase"]
Codex is applying phrase
Applying rule with key: noun
Fetching noun from dictionary
Applying rule with key: verb
Fetching verb from dictionary
Applying rule with key: preposition
Fetching preposition from dictionary
Applying rule with key: noun
Fetching noun from dictionary
Final result:
=======
bus barked at dog
=======
</code></pre></div>

Nonsensical, but still pretty cool.

Let's take a look at our DSL script for a while. It works fine, but isn't very [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself). Wouldn't it be nice to add some structure and be less repetitious? Let's try to define Dictionary and Rule entries as functions:

<div class="highlight"><pre><code class="language-bash">
dictionary
  noun 'dog', 'bus'
  verb 'barked', 'parked'
  preposition 'at'

rule
  phrase 'noun', 'verb', 'preposition', 'noun'

codex 'phrase'
</code></pre></div>

Much better. But what if we wanted different nouns to belong in different dictionary entries, say, `animal_nouns` and `vehicle_nouns`? Are we supposed to define every possible word class as a separate method? That's not very DRY!

Here's where things start getting beautiful: Ruby has a method called `method_missing` (good material [here](http://rubylearning.com/satishtalim/ruby_method_missing.html) and [here](http://www.alef1.org/ruby/method_missing/)), which by default raises a NoMethodError, but can be overridden to do some cool stuff. Let's leverage the power of `method_missing`:

<div class="highlight"><pre><code class="language-ruby">
...

def dictionary
  @state = :dictionary
end

def rule
  @state = :rule
end

def codex *rulenames
  puts "Read codex with: #{rulenames.to_s}"
  @grammar.codex << (Codex.new rulenames)
end

@state = :idle

def method_missing method, *args, &block
  case @state
  when :dictionary
    puts "Read dictionary with: #{method.to_s} #{args.to_s}"
    Dictionary.instance.add method.to_s, args
  when :rule
    puts "Read rule with: #{method.to_s} #{args.to_s}"
    @grammar.rules[method.to_s] = (Rule.new args)
  when :idle
  else
    puts "Boom! Something went wrong. I don't know what to do with #{@state.to_s}."
  end
end
</code></pre></div>

Now `method_missing` captures undefined methods and the appropriate entries are created depending on which function was last called (i.e. `dictionary` or `rule`). This relieves us from defining methods for `noun`, `verb`, etc. Pretty great, but we can do better. We still have some very trivial-looking method definitions in our DSL:

<div class="highlight"><pre><code class="language-ruby">
def dictionary
  @state = :dictionary
end

def rule
  @state = :rule
end
</code></pre></div>

What if we decide later on to add some new functionality to our DSL that works analogously to rules and dictionaries? We'd have to write more method definitions that just set the @`state` variable. Once more, Ruby offers us some DRYing magic: we can dynamically define methods just as if they were objects.

<div class="highlight"><pre><code class="language-ruby">
...

%w'rule dictionary'.each do |keyword|
  define_method(keyword) { @state = keyword.to_sym }
end
</code></pre></div>

The resulting methods are identical to the ones we defined statically with `def`. This may not seem like a great advantage over our previous code, but imagine if there were not 2 but 20 similar methods which could be dynamically defined - quite an improvement! There's still room for improvement using `define_method`. Instead of storing strings in a Dictionary, we might as well define a function that chooses an entry at random. Here's the Dictionary class:

<div class="highlight"><pre><code class="language-ruby">

require 'singleton'

class Dictionary
  include Singleton


  def add key, values
    @dicts ||= {}
    @dicts[key] = values
  end

  def fetch key
    puts "Fetching #{key} from dictionary"
    @dicts[key].sample
  end

end

</code></pre></div>

We can eliminate the need for that entire class by defining methods dynamically using a single line of code:

<div class="highlight"><pre><code class="language-ruby">
...

def method_missing method, *args, &block
  case @state
  when :dictionary
    puts "Read dictionary with: #{method.to_s} #{args.to_s}"
    define_method(method) { args.sample }

...
</code></pre></div>

If you're wondering, `sample` picks an array element at random.

So that's that: we successfully used some of Ruby's core metaprogramming tools, `method_missing` and `define_method`, to improve our little program. [Full code](https://github.com/lbrito1/ruby_textgen/tree/part-1) is hosted on Github - please not that it may differ slightly from what is presented here for didactic reasons.

In the next installment we'll continue to improve our DSL using more interesting Ruby features.
